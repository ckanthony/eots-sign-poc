import { createHash } from 'crypto';
import { signEOTS, verifyEOTSSignature } from '../src/lib/eots';
import { recoverPrivateKey } from '../src/lib/key-recovery';

// Example private key (DO NOT USE IN PRODUCTION)
const privateKey = Buffer.from(
  "914350c04b3189b493d350565909350cedf1ea1f849de3a70957ba9447c2a19a",
  "hex"
);

// Example nonce that will be reused (THIS IS THE VULNERABILITY)
const reusedNonce = Buffer.from(
  "800ce414c9d98a89f8978bdf7cdb2706125eefefd743330c68c695c180e4d45b",
  "hex"
);

async function demonstrateNonceReuseVulnerability() {
  console.log("üîê BIP340 Nonce Reuse Vulnerability Demonstration");
  console.log("==============================================\n");

  console.log("Original Private Key:", privateKey.toString('hex'));

  // Two different messages
  const message1 = "First message to sign";
  const message2 = "Second message to sign";
  
  console.log("üìù Signing two different messages with the SAME nonce (this is the vulnerability)");
  console.log("Message 1:", message1);
  console.log("Message 2:", message2);
  
  // Hash the messages
  const msg1Hash = createHash("sha256").update(message1).digest('hex');
  const msg2Hash = createHash("sha256").update(message2).digest('hex');

  // Sign both messages using the SAME nonce (this is the vulnerability)
  console.log("\nüñäÔ∏è  Creating signatures...");
  const sig1 = signEOTS(privateKey, msg1Hash, reusedNonce);
  const sig2 = signEOTS(privateKey, msg2Hash, reusedNonce);

  // Verify both signatures (they will be valid)
  console.log("\n‚úÖ Verifying signatures (both should be valid):");
  console.log("\nSignature 1 Parameters:");
  console.log("Public Key:", sig1.publicKey);
  console.log("Public Nonce:", sig1.publicNonce);
  console.log("Message Hash:", msg1Hash);
  console.log("Signature s:", sig1.s);

  console.log("\nSignature 2 Parameters:");
  console.log("Public Key:", sig2.publicKey);
  console.log("Public Nonce:", sig2.publicNonce); 
  console.log("Message Hash:", msg2Hash);
  console.log("Signature s:", sig2.s);

  const isValid1 = verifyEOTSSignature(sig1.publicKey, sig1.publicNonce, msg1Hash, sig1.s);
  const isValid2 = verifyEOTSSignature(sig2.publicKey, sig2.publicNonce, msg2Hash, sig2.s);
  
  console.log("Signature 1 valid:", isValid1);
  console.log("Signature 2 valid:", isValid2);

  console.log("\nDEMONSTRATION OF KEY RECOVERY");
  console.log("Attempting to recover private key from the two signatures...");
  
  const recoveredKey = recoverPrivateKey(
    sig1.s,
    sig2.s,
    msg1Hash,
    msg2Hash,
    sig1.publicKey,
    sig1.publicNonce // same as sig2.publicNonce since we reused the nonce
  );

  console.log("\nüîë Key Recovery Results:");
  console.log("Recovered Private Key:", recoveredKey);
  console.log("\nMatch:", privateKey.toString('hex') === recoveredKey ? "‚úÖ YES!" : "‚ùå NO");
}

// Run the demonstration
demonstrateNonceReuseVulnerability().catch(console.error); 